"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  contextKeySpan: () => contextKeySpan,
  getCurrentSpan: () => getCurrentSpan,
  getTracer: () => getTracer,
  opentelemetry: () => opentelemetry,
  record: () => record,
  setAttributes: () => setAttributes,
  startActiveSpan: () => startActiveSpan,
  startSpan: () => startSpan
});
module.exports = __toCommonJS(index_exports);
var import_elysia = require("elysia");
var import_api = require("@opentelemetry/api");
var import_sdk_node = require("@opentelemetry/sdk-node");
var headerHasToJSON = typeof new Headers().toJSON === "function";
var parseNumericString = (message) => {
  if (message.length < 16) {
    if (message.length === 0) return null;
    const length = Number(message);
    if (Number.isNaN(length)) return null;
    return length;
  }
  if (message.length === 16) {
    const number = Number(message);
    if (number.toString() !== message || message.trim().length === 0 || Number.isNaN(number))
      return null;
    return number;
  }
  return null;
};
var createActiveSpanHandler = (fn) => function(span) {
  try {
    const result = fn(span);
    if (result instanceof Promise || typeof result?.then === "function")
      return Promise.resolve(result).then(
        (value) => {
          span.end();
          return value;
        },
        (rejectResult) => {
          span.setStatus({
            code: import_api.SpanStatusCode.ERROR,
            message: rejectResult instanceof Error ? rejectResult.message : JSON.stringify(
              rejectResult ?? "Unknown error"
            )
          });
          span.recordException(rejectResult);
          span.end();
          throw rejectResult;
        }
      );
    span.end();
    return result;
  } catch (error) {
    const err = error;
    span.setStatus({
      code: import_api.SpanStatusCode.ERROR,
      message: err?.message
    });
    span.recordException(err);
    span.end();
    throw error;
  }
};
var createContext = (parent) => ({
  getValue() {
    return parent;
  },
  setValue() {
    return import_api.context.active();
  },
  deleteValue() {
    return import_api.context.active();
  }
});
var contextKeySpan = Symbol.for("OpenTelemetry Context Key SPAN");
var getTracer = () => {
  const tracer = import_api.trace.getTracer("Elysia");
  return {
    ...tracer,
    startSpan(name, options, context) {
      return tracer.startSpan(name, options, context);
    },
    startActiveSpan(...args) {
      switch (args.length) {
        case 2:
          return tracer.startActiveSpan(
            args[0],
            createActiveSpanHandler(args[1])
          );
        case 3:
          return tracer.startActiveSpan(
            args[0],
            args[1],
            createActiveSpanHandler(args[2])
          );
        case 4:
          return tracer.startActiveSpan(
            args[0],
            args[1],
            args[2],
            createActiveSpanHandler(args[3])
          );
      }
    }
  };
};
var startSpan = (name, options, context) => {
  const tracer = getTracer();
  return tracer.startSpan(name, options, context);
};
var startActiveSpan = (...args) => {
  const tracer = getTracer();
  switch (args.length) {
    case 2:
      return tracer.startActiveSpan(
        args[0],
        createActiveSpanHandler(args[1])
      );
    case 3:
      return tracer.startActiveSpan(
        args[0],
        args[1],
        createActiveSpanHandler(args[2])
      );
    case 4:
      return tracer.startActiveSpan(
        args[0],
        args[1],
        args[2],
        createActiveSpanHandler(args[3])
      );
  }
};
var record = startActiveSpan;
var getCurrentSpan = () => import_api.trace.getActiveSpan();
var setAttributes = (attributes) => !!getCurrentSpan()?.setAttributes(attributes);
var opentelemetry = ({
  serviceName = "Elysia",
  instrumentations,
  contextManager,
  checkIfShouldTrace,
  ...options
} = {}) => {
  let tracer = import_api.trace.getTracer(serviceName);
  if (tracer instanceof import_api.ProxyTracer) {
    const sdk = new import_sdk_node.NodeSDK({
      ...options,
      serviceName,
      instrumentations
    });
    sdk.start();
    tracer = import_api.trace.getTracer(serviceName);
  } else {
  }
  if (!import_api.context._getContextManager?.() && contextManager)
    try {
      contextManager.enable();
      import_api.context.setGlobalContextManager(contextManager);
    } catch {
    }
  return new import_elysia.Elysia({
    name: "@elysia/opentelemetry"
  }).wrap((fn, request) => {
    const shouldTrace = checkIfShouldTrace ? checkIfShouldTrace(request) : true;
    if (!shouldTrace) return fn;
    const headers = headerHasToJSON ? (
      // @ts-ignore bun only
      request.headers.toJSON()
    ) : Object.fromEntries(request.headers.entries());
    const ctx = import_api.propagation.extract(import_api.context.active(), headers);
    return tracer.startActiveSpan(
      "Root",
      { kind: import_api.SpanKind.SERVER },
      ctx,
      (rootSpan) => {
        const spanContext = import_api.trace.setSpan(ctx, rootSpan);
        return (...args) => {
          return import_api.context.with(spanContext, () => fn(...args));
        };
      }
    );
  }).trace(
    { as: "global" },
    ({
      id,
      onRequest,
      onParse,
      onTransform,
      onBeforeHandle,
      onHandle,
      onAfterHandle,
      onError,
      onAfterResponse,
      onMapResponse,
      context,
      context: {
        path,
        request: { method }
      }
    }) => {
      const rootSpan = import_api.trace.getActiveSpan();
      if (!rootSpan) return;
      function setParent(span) {
        if (span.ended) return;
        if (rootSpan.ended) return void span.end();
        const newContext = import_api.trace.setSpan(import_api.context.active(), span);
        const currentContext = (
          // @ts-expect-error private property
          import_api.context.active()._currentContext
        );
        currentContext?.set(
          contextKeySpan,
          newContext.getValue(contextKeySpan)
        );
      }
      function inspect(name) {
        return function inspect2({
          onEvent,
          total,
          onStop
        }) {
          if (total === 0 || // @ts-ignore
          rootSpan.ended)
            return;
          tracer.startActiveSpan(
            name,
            {},
            createContext(rootSpan),
            (event) => {
              if (
                // @ts-ignore
                rootSpan.ended
              )
                return;
              onEvent(({ name: name2, onStop: onStop2 }) => {
                tracer.startActiveSpan(
                  name2,
                  {},
                  createContext(event),
                  (span) => {
                    setParent(span);
                    onStop2(({ error }) => {
                      setParent(rootSpan);
                      if (span.ended) return;
                      if (error) {
                        rootSpan.setStatus({
                          code: import_api.SpanStatusCode.ERROR,
                          message: error.message
                        });
                        span.setAttributes({
                          "error.type": error.constructor?.name ?? error.name,
                          "error.stack": error.stack
                        });
                        span.setStatus({
                          code: import_api.SpanStatusCode.ERROR,
                          message: error.message
                        });
                      } else {
                        rootSpan.setStatus({
                          code: import_api.SpanStatusCode.OK
                        });
                        span.setStatus({
                          code: import_api.SpanStatusCode.OK
                        });
                      }
                      span.end();
                    });
                  }
                );
              });
              onStop(() => {
                setParent(rootSpan);
                if (event.ended) return;
                event.end();
              });
            }
          );
        };
      }
      const url = context.url;
      const attributes = Object.assign(/* @__PURE__ */ Object.create(null), {
        // ? Elysia Custom attribute
        "http.request.id": id,
        "http.request.method": method,
        "url.path": path,
        "url.full": url
      });
      if (context.qi && context.qi !== -1)
        attributes["url.query"] = url.slice(
          // @ts-ignore private property
          context.qi + 1
        );
      const protocolSeparator = url.indexOf("://");
      if (protocolSeparator > 0)
        attributes["url.scheme"] = url.slice(0, protocolSeparator);
      onRequest(inspect("Request"));
      onParse(inspect("Parse"));
      onTransform(inspect("Transform"));
      onBeforeHandle(inspect("BeforeHandle"));
      onHandle(({ onStop }) => {
        const span = tracer.startSpan(
          "Handle",
          {},
          createContext(rootSpan)
        );
        setParent(span);
        onStop(({ error }) => {
          setParent(rootSpan);
          if (span.ended || rootSpan.ended) return;
          if (error) {
            rootSpan.setStatus({
              code: import_api.SpanStatusCode.ERROR,
              message: error.message
            });
            span.setStatus({
              code: import_api.SpanStatusCode.ERROR,
              message: error.message
            });
            span.recordException(error);
            rootSpan.recordException(error);
          } else {
            rootSpan.setStatus({
              code: import_api.SpanStatusCode.OK
            });
            span.setStatus({
              code: import_api.SpanStatusCode.OK
            });
          }
          span.end();
        });
      });
      onAfterHandle(inspect("AfterHandle"));
      onError((event) => {
        inspect("Error")(event);
        event.onStop(() => {
          setParent(rootSpan);
          if (rootSpan.ended) return;
          if (
            // @ts-ignore
            !rootSpan.ended
          )
            rootSpan.end();
        });
      });
      onMapResponse(inspect("MapResponse"));
      onTransform(() => {
        const { cookie, body, request, route, path: path2 } = context;
        if (route)
          rootSpan.updateName(
            // @ts-ignore private property
            `${method} ${route || path2}`
          );
        if (context.route) attributes["http.route"] = context.route;
        {
          let contentLength = request.headers.get("content-length");
          if (contentLength) {
            const number = parseNumericString(contentLength);
            if (number)
              attributes["http.request_content_length"] = number;
          }
        }
        {
          const userAgent = request.headers.get("User-Agent");
          if (userAgent)
            attributes["user_agent.original"] = userAgent;
        }
        const server = context.server;
        if (server) {
          attributes["server.port"] = server.port ?? 80;
          attributes["server.address"] = server.url.hostname;
          attributes["server.address"] = server.url.hostname;
        }
        let headers;
        {
          let hasHeaders;
          let _headers;
          if (context.headers) {
            hasHeaders = true;
            headers = context.headers;
            _headers = Object.entries(context.headers);
          } else if (hasHeaders = headerHasToJSON) {
            headers = request.headers.toJSON();
            _headers = Object.entries(headers);
          } else {
            headers = {};
            _headers = request.headers.entries();
          }
          for (let [key, value] of _headers) {
            key = key.toLowerCase();
            if (hasHeaders) {
              if (key === "user-agent") continue;
              if (typeof value === "object")
                attributes[`http.request.header.${key}`] = JSON.stringify(value);
              else if (value !== void 0)
                attributes[`http.request.header.${key}`] = value;
              continue;
            }
            if (typeof value === "object")
              headers[key] = attributes[`http.request.header.${key}`] = JSON.stringify(value);
            else if (value !== void 0) {
              if (key === "user-agent") {
                headers[key] = value;
                continue;
              }
              headers[key] = attributes[`http.request.header.${key}`] = value;
            }
          }
        }
        {
          let headers2;
          if (context.set.headers instanceof Headers) {
            if (headerHasToJSON)
              headers2 = Object.entries(
                // @ts-ignore bun only
                context.set.headers.toJSON()
              );
            else headers2 = context.set.headers.entries();
          } else headers2 = Object.entries(context.set.headers);
          for (let [key, value] of headers2) {
            key = key.toLowerCase();
            if (typeof value === "object")
              attributes[`http.response.header.${key}`] = JSON.stringify(value);
            else
              attributes[`http.response.header.${key}`] = value;
          }
        }
        if (context.ip)
          attributes["client.address"] = context.ip;
        else {
          const ip = headers["true-client-ip"] ?? headers["cf-connection-ip"] ?? headers["x-forwarded-for"] ?? headers["x-real-ip"] ?? server?.requestIP(request);
          if (ip)
            attributes["client.address"] = typeof ip === "string" ? ip : ip.address ?? ip.toString();
        }
        if (cookie) {
          const _cookie = {};
          for (const [key, { value }] of Object.entries(cookie))
            _cookie[key] = JSON.stringify(value);
          attributes["http.request.cookie"] = JSON.stringify(_cookie);
        }
        rootSpan.setAttributes(attributes);
      });
      onMapResponse(() => {
        const body = context.body;
        if (body !== void 0 && body !== null) {
          const value = typeof body === "object" ? JSON.stringify(body) : body.toString();
          attributes["http.request.body"] = value;
          if (typeof body === "object") {
            if (body instanceof Uint8Array)
              attributes["http.request.body.size"] = body.length;
            else if (body instanceof ArrayBuffer)
              attributes["http.request.body.size"] = body.byteLength;
            else if (body instanceof Blob)
              attributes["http.request.body.size"] = body.size;
            attributes["http.request.body.size"] = value.length;
          } else {
            attributes["http.request.body.size"] = value.length;
          }
        }
        {
          let status = context.set.status ?? 200;
          if (typeof status === "string")
            status = import_elysia.StatusMap[status] ?? 200;
          attributes["http.response.status_code"] = status;
        }
        const response = context.responseValue;
        if (response !== void 0)
          switch (typeof response) {
            case "object":
              if (response instanceof Response) {
              } else if (response instanceof Uint8Array)
                attributes["http.response.body.size"] = response.length;
              else if (response instanceof ArrayBuffer)
                attributes["http.response.body.size"] = response.byteLength;
              else if (response instanceof Blob)
                attributes["http.response.body.size"] = response.size;
              else {
                const value = JSON.stringify(response);
                attributes["http.response.body"] = value;
                attributes["http.response.body.size"] = value.length;
              }
              break;
            default:
              if (response === void 0 || response === null)
                attributes["http.response.body.size"] = 0;
              else {
                const value = response.toString();
                attributes["http.response.body"] = value;
                attributes["http.response.body.size"] = value.length;
              }
          }
      });
      onAfterResponse((event) => {
        inspect("AfterResponse")(event);
        {
          let status = context.set.status ?? 200;
          if (typeof status === "string")
            status = import_elysia.StatusMap[status] ?? 200;
          attributes["http.response.status_code"] = status;
        }
        const body = context.body;
        if (body !== void 0 && body !== null) {
          const value = typeof body === "object" ? JSON.stringify(body) : body.toString();
          attributes["http.request.body"] = value;
          if (typeof body === "object") {
            if (body instanceof Uint8Array)
              attributes["http.request.body.size"] = body.length;
            else if (body instanceof ArrayBuffer)
              attributes["http.request.body.size"] = body.byteLength;
            else if (body instanceof Blob)
              attributes["http.request.body.size"] = body.size;
            attributes["http.request.body.size"] = value.length;
          } else {
            attributes["http.request.body.size"] = value.length;
          }
        }
        event.onStop(() => {
          setParent(rootSpan);
          if (rootSpan.ended) return;
          if (
            // @ts-ignore
            !rootSpan.ended
          )
            rootSpan.end();
        });
      });
      context.request.signal.addEventListener("abort", () => {
        const active = import_api.trace.getActiveSpan();
        if (active && !active.ended) active.end();
        if (rootSpan.ended) return;
        rootSpan.setStatus({
          code: import_api.SpanStatusCode.ERROR,
          message: "Request aborted"
        });
        rootSpan.end();
      });
    }
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  contextKeySpan,
  getCurrentSpan,
  getTracer,
  opentelemetry,
  record,
  setAttributes,
  startActiveSpan,
  startSpan
});
