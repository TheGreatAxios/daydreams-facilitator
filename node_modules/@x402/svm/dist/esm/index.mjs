import {
  ExactSvmScheme
} from "./chunk-YWMR6S2D.mjs";
import {
  COMPUTE_BUDGET_PROGRAM_ADDRESS,
  DEFAULT_COMPUTE_UNIT_LIMIT,
  DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS,
  DEVNET_RPC_URL,
  DEVNET_WS_URL,
  MAINNET_RPC_URL,
  MAINNET_WS_URL,
  MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS,
  SOLANA_DEVNET_CAIP2,
  SOLANA_MAINNET_CAIP2,
  SOLANA_TESTNET_CAIP2,
  SVM_ADDRESS_REGEX,
  TESTNET_RPC_URL,
  TESTNET_WS_URL,
  TOKEN_2022_PROGRAM_ADDRESS,
  TOKEN_PROGRAM_ADDRESS,
  USDC_DEVNET_ADDRESS,
  USDC_MAINNET_ADDRESS,
  USDC_TESTNET_ADDRESS,
  V1_TO_V2_NETWORK_MAP,
  convertToTokenAmount,
  createRpcClient,
  decodeTransactionFromPayload,
  getTokenPayerFromTransaction,
  getUsdcAddress,
  normalizeNetwork,
  validateSvmAddress
} from "./chunk-R3KFRQHE.mjs";

// src/signer.ts
import { getBase64EncodedWireTransaction } from "@solana/kit";
function toClientSvmSigner(signer) {
  return signer;
}
function createRpcCapabilitiesFromRpc(rpc) {
  return {
    getBalance: async (address) => {
      const result = await rpc.getBalance(address).send();
      return result.value;
    },
    getTokenAccountBalance: async (address) => {
      const accountInfo = await rpc.getAccountInfo(address, {
        encoding: "jsonParsed"
      }).send();
      if (!accountInfo.value) {
        throw new Error(`Token account not found: ${address}`);
      }
      const parsed = accountInfo.value.data;
      return BigInt(parsed.parsed.info.tokenAmount.amount);
    },
    getLatestBlockhash: async () => {
      const result = await rpc.getLatestBlockhash().send();
      return {
        blockhash: result.value.blockhash,
        lastValidBlockHeight: result.value.lastValidBlockHeight
      };
    },
    simulateTransaction: async (transaction, config) => {
      return await rpc.simulateTransaction(transaction, config).send();
    },
    sendTransaction: async (transaction) => {
      return await rpc.sendTransaction(transaction, {
        encoding: "base64"
      }).send();
    },
    confirmTransaction: async (signature) => {
      let confirmed = false;
      let attempts = 0;
      const maxAttempts = 30;
      while (!confirmed && attempts < maxAttempts) {
        const status = await rpc.getSignatureStatuses([signature]).send();
        if (status.value[0]?.confirmationStatus === "confirmed" || status.value[0]?.confirmationStatus === "finalized") {
          confirmed = true;
          return status.value[0];
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        attempts++;
      }
      throw new Error("Transaction confirmation timeout");
    },
    fetchMint: async (address) => {
      const { fetchMint } = await import("@solana-program/token-2022");
      return await fetchMint(rpc, address);
    }
  };
}
function toFacilitatorSvmSigner(signer, rpcConfig) {
  let rpcMap = {};
  let defaultRpcUrl;
  if (rpcConfig) {
    if ("defaultRpcUrl" in rpcConfig && typeof rpcConfig.defaultRpcUrl === "string") {
      defaultRpcUrl = rpcConfig.defaultRpcUrl;
    } else if ("getBalance" in rpcConfig || "getSlot" in rpcConfig) {
      rpcMap["*"] = rpcConfig;
    } else {
      rpcMap = rpcConfig;
    }
  }
  const getRpcForNetwork = (network) => {
    if (rpcMap[network]) {
      return rpcMap[network];
    }
    if (rpcMap["*"]) {
      return rpcMap["*"];
    }
    return createRpcClient(network, defaultRpcUrl);
  };
  return {
    getAddresses: () => {
      return [signer.address];
    },
    signTransaction: async (transaction, feePayer, _) => {
      if (feePayer !== signer.address) {
        throw new Error(`No signer for feePayer ${feePayer}. Available: ${signer.address}`);
      }
      const tx = decodeTransactionFromPayload({ transaction });
      const signableMessage = {
        content: tx.messageBytes,
        signatures: tx.signatures
      };
      const [facilitatorSignatureDictionary] = await signer.signMessages([
        signableMessage
      ]);
      const fullySignedTx = {
        ...tx,
        signatures: {
          ...tx.signatures,
          ...facilitatorSignatureDictionary
        }
      };
      return getBase64EncodedWireTransaction(fullySignedTx);
    },
    simulateTransaction: async (transaction, network) => {
      const rpc = getRpcForNetwork(network);
      const result = await rpc.simulateTransaction(transaction, {
        sigVerify: true,
        replaceRecentBlockhash: false,
        commitment: "confirmed",
        encoding: "base64"
      }).send();
      if (result.value.err) {
        throw new Error(`Simulation failed: ${JSON.stringify(result.value.err)}`);
      }
    },
    sendTransaction: async (transaction, network) => {
      const rpc = getRpcForNetwork(network);
      return await rpc.sendTransaction(transaction, {
        encoding: "base64"
      }).send();
    },
    confirmTransaction: async (signature, network) => {
      const rpc = getRpcForNetwork(network);
      const rpcCapabilities = createRpcCapabilitiesFromRpc(rpc);
      await rpcCapabilities.confirmTransaction(signature);
    }
  };
}
export {
  COMPUTE_BUDGET_PROGRAM_ADDRESS,
  DEFAULT_COMPUTE_UNIT_LIMIT,
  DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS,
  DEVNET_RPC_URL,
  DEVNET_WS_URL,
  ExactSvmScheme,
  MAINNET_RPC_URL,
  MAINNET_WS_URL,
  MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS,
  SOLANA_DEVNET_CAIP2,
  SOLANA_MAINNET_CAIP2,
  SOLANA_TESTNET_CAIP2,
  SVM_ADDRESS_REGEX,
  TESTNET_RPC_URL,
  TESTNET_WS_URL,
  TOKEN_2022_PROGRAM_ADDRESS,
  TOKEN_PROGRAM_ADDRESS,
  USDC_DEVNET_ADDRESS,
  USDC_MAINNET_ADDRESS,
  USDC_TESTNET_ADDRESS,
  V1_TO_V2_NETWORK_MAP,
  convertToTokenAmount,
  createRpcClient,
  decodeTransactionFromPayload,
  getTokenPayerFromTransaction,
  getUsdcAddress,
  normalizeNetwork,
  toClientSvmSigner,
  toFacilitatorSvmSigner,
  validateSvmAddress
};
//# sourceMappingURL=index.mjs.map