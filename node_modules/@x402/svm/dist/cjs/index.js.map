{"version":3,"sources":["../../src/index.ts","../../src/exact/client/scheme.ts","../../src/constants.ts","../../src/utils.ts","../../src/signer.ts"],"sourcesContent":["/**\n * @module @x402/svm - x402 Payment Protocol SVM Implementation\n *\n * This module provides the SVM-specific implementation of the x402 payment protocol.\n */\n\n// Export V2 implementations (default)\nexport { ExactSvmScheme } from \"./exact\";\n\n// Export signer utilities and types\nexport { toClientSvmSigner, toFacilitatorSvmSigner } from \"./signer\";\nexport type {\n  ClientSvmSigner,\n  FacilitatorSvmSigner,\n  FacilitatorRpcClient,\n  FacilitatorRpcConfig,\n  ClientSvmConfig,\n} from \"./signer\";\n\n// Export payload types\nexport type { ExactSvmPayloadV1, ExactSvmPayloadV2 } from \"./types\";\n\n// Export constants\nexport * from \"./constants\";\n\n// Export utilities\nexport * from \"./utils\";\n","import {\n  getSetComputeUnitLimitInstruction,\n  setTransactionMessageComputeUnitPrice,\n} from \"@solana-program/compute-budget\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport {\n  fetchMint,\n  findAssociatedTokenPda,\n  getTransferCheckedInstruction,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport {\n  appendTransactionMessageInstructions,\n  createTransactionMessage,\n  getBase64EncodedWireTransaction,\n  partiallySignTransactionMessageWithSigners,\n  pipe,\n  prependTransactionMessageInstruction,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  type Address,\n} from \"@solana/kit\";\nimport type { PaymentPayload, PaymentRequirements, SchemeNetworkClient } from \"@x402/core/types\";\nimport {\n  DEFAULT_COMPUTE_UNIT_LIMIT,\n  DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS,\n} from \"../../constants\";\nimport type { ClientSvmConfig, ClientSvmSigner } from \"../../signer\";\nimport type { ExactSvmPayloadV2 } from \"../../types\";\nimport { createRpcClient } from \"../../utils\";\n\n/**\n * SVM client implementation for the Exact payment scheme.\n */\nexport class ExactSvmScheme implements SchemeNetworkClient {\n  readonly scheme = \"exact\";\n\n  /**\n   * Creates a new ExactSvmClient instance.\n   *\n   * @param signer - The SVM signer for client operations\n   * @param config - Optional configuration with custom RPC URL\n   * @returns ExactSvmClient instance\n   */\n  constructor(\n    private readonly signer: ClientSvmSigner,\n    private readonly config?: ClientSvmConfig,\n  ) {}\n\n  /**\n   * Creates a payment payload for the Exact scheme.\n   *\n   * @param x402Version - The x402 protocol version\n   * @param paymentRequirements - The payment requirements\n   * @returns Promise resolving to a payment payload\n   */\n  async createPaymentPayload(\n    x402Version: number,\n    paymentRequirements: PaymentRequirements,\n  ): Promise<Pick<PaymentPayload, \"x402Version\" | \"payload\">> {\n    const rpc = createRpcClient(paymentRequirements.network, this.config?.rpcUrl);\n\n    const tokenMint = await fetchMint(rpc, paymentRequirements.asset as Address);\n    const tokenProgramAddress = tokenMint.programAddress;\n\n    if (\n      tokenProgramAddress.toString() !== TOKEN_PROGRAM_ADDRESS.toString() &&\n      tokenProgramAddress.toString() !== TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      throw new Error(\"Asset was not created by a known token program\");\n    }\n\n    const [sourceATA] = await findAssociatedTokenPda({\n      mint: paymentRequirements.asset as Address,\n      owner: this.signer.address,\n      tokenProgram: tokenProgramAddress,\n    });\n\n    const [destinationATA] = await findAssociatedTokenPda({\n      mint: paymentRequirements.asset as Address,\n      owner: paymentRequirements.payTo as Address,\n      tokenProgram: tokenProgramAddress,\n    });\n\n    const transferIx = getTransferCheckedInstruction(\n      {\n        source: sourceATA,\n        mint: paymentRequirements.asset as Address,\n        destination: destinationATA,\n        authority: this.signer,\n        amount: BigInt(paymentRequirements.amount),\n        decimals: tokenMint.data.decimals,\n      },\n      { programAddress: tokenProgramAddress },\n    );\n\n    // Facilitator must provide feePayer to cover transaction fees\n    const feePayer = paymentRequirements.extra?.feePayer as Address;\n    if (!feePayer) {\n      throw new Error(\"feePayer is required in paymentRequirements.extra for SVM transactions\");\n    }\n\n    const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\n    const tx = pipe(\n      createTransactionMessage({ version: 0 }),\n      tx => setTransactionMessageComputeUnitPrice(DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS, tx),\n      tx => setTransactionMessageFeePayer(feePayer, tx),\n      tx =>\n        prependTransactionMessageInstruction(\n          getSetComputeUnitLimitInstruction({ units: DEFAULT_COMPUTE_UNIT_LIMIT }),\n          tx,\n        ),\n      tx => appendTransactionMessageInstructions([transferIx], tx),\n      tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    );\n\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(tx);\n    const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n    const payload: ExactSvmPayloadV2 = {\n      transaction: base64EncodedWireTransaction,\n    };\n\n    return {\n      x402Version,\n      payload,\n    };\n  }\n}\n","/**\n * Token program addresses for SPL Token and Token-2022\n * These addresses are the same across all Solana networks (mainnet, devnet, testnet)\n */\nexport const TOKEN_PROGRAM_ADDRESS = \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\nexport const TOKEN_2022_PROGRAM_ADDRESS = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\nexport const COMPUTE_BUDGET_PROGRAM_ADDRESS = \"ComputeBudget111111111111111111111111111111\";\n\n/**\n * Default RPC URLs for Solana networks\n */\nexport const DEVNET_RPC_URL = \"https://api.devnet.solana.com\";\nexport const TESTNET_RPC_URL = \"https://api.testnet.solana.com\";\nexport const MAINNET_RPC_URL = \"https://api.mainnet-beta.solana.com\";\nexport const DEVNET_WS_URL = \"wss://api.devnet.solana.com\";\nexport const TESTNET_WS_URL = \"wss://api.testnet.solana.com\";\nexport const MAINNET_WS_URL = \"wss://api.mainnet-beta.solana.com\";\n\n/**\n * USDC token mint addresses (default stablecoin)\n */\nexport const USDC_MAINNET_ADDRESS = \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\";\nexport const USDC_DEVNET_ADDRESS = \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\";\nexport const USDC_TESTNET_ADDRESS = \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\"; // Same as devnet\n\n/**\n * Compute budget configuration\n * All prices are in microlamports (1 lamport = 1,000,000 microlamports)\n */\nexport const DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 1;\nexport const MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 5_000_000; // 5 lamports\nexport const DEFAULT_COMPUTE_UNIT_LIMIT = 6500;\n\n/**\n * Solana address validation regex (base58, 32-44 characters)\n */\nexport const SVM_ADDRESS_REGEX = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n\n/**\n * CAIP-2 network identifiers for Solana (V2)\n */\nexport const SOLANA_MAINNET_CAIP2 = \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\";\nexport const SOLANA_DEVNET_CAIP2 = \"solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1\";\nexport const SOLANA_TESTNET_CAIP2 = \"solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z\";\n\n/**\n * V1 to V2 network identifier mappings (for backwards compatibility)\n * V1 used simple names like solana, V2 uses CAIP-2\n */\nexport const V1_TO_V2_NETWORK_MAP: Record<string, string> = {\n  solana: SOLANA_MAINNET_CAIP2,\n  \"solana-devnet\": SOLANA_DEVNET_CAIP2,\n  \"solana-testnet\": SOLANA_TESTNET_CAIP2,\n};\n","import {\n  getBase64Encoder,\n  getTransactionDecoder,\n  getCompiledTransactionMessageDecoder,\n  type Transaction,\n  type CompiledTransactionMessage,\n  createSolanaRpc,\n  devnet,\n  testnet,\n  mainnet,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcTestnet,\n  type SolanaRpcApiTestnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n} from \"@solana/kit\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport type { Network } from \"@x402/core/types\";\nimport {\n  SVM_ADDRESS_REGEX,\n  DEVNET_RPC_URL,\n  TESTNET_RPC_URL,\n  MAINNET_RPC_URL,\n  USDC_MAINNET_ADDRESS,\n  USDC_DEVNET_ADDRESS,\n  USDC_TESTNET_ADDRESS,\n  SOLANA_MAINNET_CAIP2,\n  SOLANA_DEVNET_CAIP2,\n  SOLANA_TESTNET_CAIP2,\n  V1_TO_V2_NETWORK_MAP,\n} from \"./constants\";\nimport type { ExactSvmPayloadV1 } from \"./types\";\n\n/**\n * Normalize network identifier to CAIP-2 format\n * Handles both V1 names (solana, solana-devnet) and V2 CAIP-2 format\n *\n * @param network - Network identifier (V1 or V2 format)\n * @returns CAIP-2 network identifier\n */\nexport function normalizeNetwork(network: Network): string {\n  // If it's already CAIP-2 format (contains \":\"), validate it's supported\n  if (network.includes(\":\")) {\n    const supported = [SOLANA_MAINNET_CAIP2, SOLANA_DEVNET_CAIP2, SOLANA_TESTNET_CAIP2];\n    if (!supported.includes(network)) {\n      throw new Error(`Unsupported SVM network: ${network}`);\n    }\n    return network;\n  }\n\n  // Otherwise, it's a V1 network name, convert to CAIP-2\n  const caip2Network = V1_TO_V2_NETWORK_MAP[network];\n  if (!caip2Network) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return caip2Network;\n}\n\n/**\n * Validate Solana address format\n *\n * @param address - Base58 encoded address string\n * @returns true if address is valid, false otherwise\n */\nexport function validateSvmAddress(address: string): boolean {\n  return SVM_ADDRESS_REGEX.test(address);\n}\n\n/**\n * Decode a base64 encoded transaction from an SVM payload\n *\n * @param svmPayload - The SVM payload containing a base64 encoded transaction\n * @returns Decoded Transaction object\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayloadV1): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"Error decoding transaction:\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Extract the token sender (owner of the source token account) from a TransferChecked instruction\n *\n * @param transaction - The decoded transaction\n * @returns The token payer address as a base58 string\n */\nexport function getTokenPayerFromTransaction(transaction: Transaction): string {\n  const compiled = getCompiledTransactionMessageDecoder().decode(\n    transaction.messageBytes,\n  ) as CompiledTransactionMessage;\n  const staticAccounts = compiled.staticAccounts ?? [];\n  const instructions = compiled.instructions ?? [];\n\n  for (const ix of instructions) {\n    const programIndex = ix.programAddressIndex;\n    const programAddress = staticAccounts[programIndex].toString();\n\n    // Check if this is a token program instruction\n    if (\n      programAddress === TOKEN_PROGRAM_ADDRESS.toString() ||\n      programAddress === TOKEN_2022_PROGRAM_ADDRESS.toString()\n    ) {\n      const accountIndices: number[] = ix.accountIndices ?? [];\n      // TransferChecked account order: [source, mint, destination, owner, ...]\n      if (accountIndices.length >= 4) {\n        const ownerIndex = accountIndices[3];\n        const ownerAddress = staticAccounts[ownerIndex].toString();\n        if (ownerAddress) return ownerAddress;\n      }\n    }\n  }\n\n  return \"\";\n}\n\n/**\n * Create an RPC client for the specified network\n *\n * @param network - Network identifier (CAIP-2 or V1 format)\n * @param customRpcUrl - Optional custom RPC URL\n * @returns RPC client for the specified network\n */\nexport function createRpcClient(\n  network: Network,\n  customRpcUrl?: string,\n):\n  | RpcDevnet<SolanaRpcApiDevnet>\n  | RpcTestnet<SolanaRpcApiTestnet>\n  | RpcMainnet<SolanaRpcApiMainnet> {\n  const caip2Network = normalizeNetwork(network);\n\n  switch (caip2Network) {\n    case SOLANA_DEVNET_CAIP2: {\n      const url = customRpcUrl || DEVNET_RPC_URL;\n      return createSolanaRpc(devnet(url)) as RpcDevnet<SolanaRpcApiDevnet>;\n    }\n    case SOLANA_TESTNET_CAIP2: {\n      const url = customRpcUrl || TESTNET_RPC_URL;\n      return createSolanaRpc(testnet(url)) as RpcTestnet<SolanaRpcApiTestnet>;\n    }\n    case SOLANA_MAINNET_CAIP2: {\n      const url = customRpcUrl || MAINNET_RPC_URL;\n      return createSolanaRpc(mainnet(url)) as RpcMainnet<SolanaRpcApiMainnet>;\n    }\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n\n/**\n * Get the default USDC mint address for a network\n *\n * @param network - Network identifier (CAIP-2 or V1 format)\n * @returns USDC mint address for the network\n */\nexport function getUsdcAddress(network: Network): string {\n  const caip2Network = normalizeNetwork(network);\n\n  switch (caip2Network) {\n    case SOLANA_MAINNET_CAIP2:\n      return USDC_MAINNET_ADDRESS;\n    case SOLANA_DEVNET_CAIP2:\n      return USDC_DEVNET_ADDRESS;\n    case SOLANA_TESTNET_CAIP2:\n      return USDC_TESTNET_ADDRESS;\n    default:\n      throw new Error(`No USDC address configured for network: ${network}`);\n  }\n}\n\n/**\n * Convert a decimal amount to token smallest units\n *\n * @param decimalAmount - The decimal amount (e.g., \"0.10\")\n * @param decimals - The number of decimals for the token (e.g., 6 for USDC)\n * @returns The amount in smallest units as a string\n */\nexport function convertToTokenAmount(decimalAmount: string, decimals: number): string {\n  const amount = parseFloat(decimalAmount);\n  if (isNaN(amount)) {\n    throw new Error(`Invalid amount: ${decimalAmount}`);\n  }\n  // Convert to smallest unit (e.g., for USDC with 6 decimals: 0.10 * 10^6 = 100000)\n  const tokenAmount = Math.floor(amount * Math.pow(10, decimals));\n  return tokenAmount.toString();\n}\n","import type {\n  TransactionSigner,\n  MessagePartialSigner,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  RpcTestnet,\n  SolanaRpcApiTestnet,\n  RpcMainnet,\n  SolanaRpcApiMainnet,\n  Address,\n} from \"@solana/kit\";\nimport { getBase64EncodedWireTransaction } from \"@solana/kit\";\nimport { createRpcClient, decodeTransactionFromPayload } from \"./utils\";\n\n/**\n * Client-side signer for creating and signing Solana transactions\n * This is a wrapper around TransactionSigner from @solana/kit\n */\nexport type ClientSvmSigner = TransactionSigner;\n\n/**\n * Configuration for client operations\n */\nexport type ClientSvmConfig = {\n  /**\n   * Optional custom RPC URL for the client to use\n   */\n  rpcUrl?: string;\n};\n\n/**\n * Signing capabilities needed by the facilitator\n * Must support both transaction and message signing\n * KeyPairSigner from @solana/kit satisfies this interface\n */\nexport type FacilitatorSigningCapabilities = TransactionSigner & MessagePartialSigner;\n\n/**\n * RPC client type from @solana/kit\n * Can be devnet, testnet, or mainnet RPC client\n */\nexport type FacilitatorRpcClient =\n  | RpcDevnet<SolanaRpcApiDevnet>\n  | RpcTestnet<SolanaRpcApiTestnet>\n  | RpcMainnet<SolanaRpcApiMainnet>;\n\n/**\n * RPC capabilities needed by the facilitator for verification and settlement\n * This is a legacy interface for custom RPC implementations\n */\nexport type FacilitatorRpcCapabilities = {\n  /**\n   * Get the SOL balance of an account\n   *\n   * @param address - Base58 encoded address\n   * @returns Balance in lamports\n   */\n  getBalance(address: string): Promise<bigint>;\n\n  /**\n   * Get the token account balance\n   *\n   * @param address - Base58 encoded token account address\n   * @returns Token balance in smallest units\n   */\n  getTokenAccountBalance(address: string): Promise<bigint>;\n\n  /**\n   * Get the latest blockhash information\n   *\n   * @returns Blockhash and last valid block height\n   */\n  getLatestBlockhash(): Promise<{ blockhash: string; lastValidBlockHeight: bigint }>;\n\n  /**\n   * Simulate a transaction to check if it would succeed\n   *\n   * @param transaction - Base64 encoded transaction\n   * @param config - Simulation configuration\n   * @returns Simulation result\n   */\n  simulateTransaction(transaction: string, config: unknown): Promise<unknown>;\n\n  /**\n   * Send a transaction to the network\n   *\n   * @param transaction - Base64 encoded signed transaction\n   * @returns Transaction signature\n   */\n  sendTransaction(transaction: string): Promise<string>;\n\n  /**\n   * Wait for transaction confirmation\n   *\n   * @param signature - Transaction signature\n   * @returns Confirmation result\n   */\n  confirmTransaction(signature: string): Promise<unknown>;\n\n  /**\n   * Fetch token mint information\n   *\n   * @param address - Base58 encoded mint address\n   * @returns Mint information including decimals\n   */\n  fetchMint(address: string): Promise<unknown>;\n};\n\n/**\n * Minimal facilitator signer interface for SVM operations.\n * Supports multiple signers for load balancing and high availability.\n * All implementation details (RPC clients, key management, signature handling) are hidden.\n */\nexport type FacilitatorSvmSigner = {\n  /**\n   * Get all addresses this facilitator can use as fee payers\n   * Enables dynamic address selection for load balancing and key rotation\n   *\n   * @returns Array of addresses available for signing\n   */\n  getAddresses(): readonly Address[];\n\n  /**\n   * Sign a partially-signed transaction with the signer matching feePayer\n   * Transaction is decoded, signed, and re-encoded internally\n   *\n   * @param transaction - Base64 encoded partially-signed transaction\n   * @param feePayer - Fee payer address (determines which signer to use)\n   * @param network - CAIP-2 network identifier\n   * @returns Base64 encoded fully-signed transaction\n   * @throws Error if no signer exists for feePayer or signing fails\n   */\n  signTransaction(transaction: string, feePayer: Address, network: string): Promise<string>;\n\n  /**\n   * Simulate a signed transaction to verify it would succeed\n   * Implementation manages RPC client selection and simulation details\n   *\n   * @param transaction - Base64 encoded signed transaction\n   * @param network - CAIP-2 network identifier\n   * @throws Error if simulation fails\n   */\n  simulateTransaction(transaction: string, network: string): Promise<void>;\n\n  /**\n   * Send a signed transaction to the network\n   * Implementation manages RPC client selection and sending details\n   *\n   * @param transaction - Base64 encoded signed transaction\n   * @param network - CAIP-2 network identifier\n   * @returns Transaction signature\n   * @throws Error if send fails\n   */\n  sendTransaction(transaction: string, network: string): Promise<string>;\n\n  /**\n   * Wait for transaction confirmation\n   * Allows signer to implement custom retry logic, timeouts, and confirmation strategies\n   *\n   * @param signature - Transaction signature to confirm\n   * @param network - CAIP-2 network identifier\n   * @returns Promise that resolves when transaction is confirmed\n   * @throws Error if confirmation fails or times out\n   */\n  confirmTransaction(signature: string, network: string): Promise<void>;\n};\n\n/**\n * Convert a signer to ClientSvmSigner (identity function for type safety)\n *\n * @param signer - The signer to convert\n * @returns The signer as ClientSvmSigner\n */\nexport function toClientSvmSigner(signer: ClientSvmSigner): ClientSvmSigner {\n  return signer;\n}\n\n/**\n * Create RPC capabilities from a Solana Kit RPC client\n *\n * @param rpc - The RPC client from @solana/kit\n * @returns RPC capabilities for the facilitator\n */\nexport function createRpcCapabilitiesFromRpc(\n  rpc: FacilitatorRpcClient,\n): FacilitatorRpcCapabilities {\n  return {\n    getBalance: async address => {\n      const result = await rpc.getBalance(address as never).send();\n      return result.value;\n    },\n    getTokenAccountBalance: async address => {\n      const accountInfo = await rpc\n        .getAccountInfo(address as never, {\n          encoding: \"jsonParsed\",\n        })\n        .send();\n\n      if (!accountInfo.value) {\n        throw new Error(`Token account not found: ${address}`);\n      }\n\n      const parsed = accountInfo.value.data as {\n        parsed: { info: { tokenAmount: { amount: string } } };\n      };\n      return BigInt(parsed.parsed.info.tokenAmount.amount);\n    },\n    getLatestBlockhash: async () => {\n      const result = await rpc.getLatestBlockhash().send();\n      return {\n        blockhash: result.value.blockhash,\n        lastValidBlockHeight: result.value.lastValidBlockHeight,\n      };\n    },\n    simulateTransaction: async (transaction, config) => {\n      return await rpc.simulateTransaction(transaction as never, config as never).send();\n    },\n    sendTransaction: async transaction => {\n      return await rpc\n        .sendTransaction(transaction as never, {\n          encoding: \"base64\",\n        })\n        .send();\n    },\n    confirmTransaction: async signature => {\n      let confirmed = false;\n      let attempts = 0;\n      const maxAttempts = 30;\n\n      while (!confirmed && attempts < maxAttempts) {\n        const status = await rpc.getSignatureStatuses([signature as never]).send();\n\n        if (\n          status.value[0]?.confirmationStatus === \"confirmed\" ||\n          status.value[0]?.confirmationStatus === \"finalized\"\n        ) {\n          confirmed = true;\n          return status.value[0];\n        }\n\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        attempts++;\n      }\n\n      throw new Error(\"Transaction confirmation timeout\");\n    },\n    fetchMint: async address => {\n      const { fetchMint } = await import(\"@solana-program/token-2022\");\n      return await fetchMint(rpc, address as never);\n    },\n  };\n}\n\n/**\n * RPC configuration for the facilitator\n * Can be a single RPC (all networks), a network mapping, or config options\n */\nexport type FacilitatorRpcConfig =\n  | FacilitatorRpcClient // Single RPC for all networks\n  | Record<string, FacilitatorRpcClient> // Per-network RPC mapping\n  | { defaultRpcUrl?: string }; // Custom default RPC URL\n\n/**\n * Create a FacilitatorSvmSigner from a TransactionSigner and optional RPC config\n *\n * @param signer - The TransactionSigner (e.g., from createKeyPairSignerFromBytes)\n * @param rpcConfig - Optional RPC configuration (single RPC, per-network map, or config)\n * @returns A complete FacilitatorSvmSigner\n *\n * @example\n * ```ts\n * import { createKeyPairSignerFromBytes, createSolanaRpc, devnet } from \"@solana/kit\";\n *\n * // Option 1: No RPC - use defaults (SIMPLEST)\n * const keypair = await createKeyPairSignerFromBytes(privateKeyBytes);\n * const facilitator = toFacilitatorSvmSigner(keypair);\n *\n * // Option 2: Single RPC for all networks\n * const rpc = createSolanaRpc(devnet(\"https://api.devnet.solana.com\"));\n * const facilitator = toFacilitatorSvmSigner(keypair, rpc);\n *\n * // Option 3: Per-network RPC (FLEXIBLE)\n * const facilitator = toFacilitatorSvmSigner(keypair, {\n *   [SOLANA_MAINNET_CAIP2]: myQuickNodeRpc,\n *   // Devnet/testnet use defaults\n * });\n *\n * // Option 4: Custom default RPC URL\n * const facilitator = toFacilitatorSvmSigner(keypair, {\n *   defaultRpcUrl: \"https://my-rpc.com\"\n * });\n * ```\n */\nexport function toFacilitatorSvmSigner(\n  signer: TransactionSigner & MessagePartialSigner,\n  rpcConfig?: FacilitatorRpcConfig,\n): FacilitatorSvmSigner {\n  let rpcMap: Record<string, FacilitatorRpcClient> = {};\n  let defaultRpcUrl: string | undefined;\n\n  if (rpcConfig) {\n    // Check if it's a config object with defaultRpcUrl\n    if (\"defaultRpcUrl\" in rpcConfig && typeof rpcConfig.defaultRpcUrl === \"string\") {\n      defaultRpcUrl = rpcConfig.defaultRpcUrl;\n    }\n    // Check if it's a single RPC client\n    else if (\"getBalance\" in rpcConfig || \"getSlot\" in rpcConfig) {\n      rpcMap[\"*\"] = rpcConfig as FacilitatorRpcClient;\n    }\n    // Otherwise, it's a network mapping\n    else {\n      rpcMap = rpcConfig as Record<string, FacilitatorRpcClient>;\n    }\n  }\n\n  const getRpcForNetwork = (network: string): FacilitatorRpcClient => {\n    // 1. Check for exact network match\n    if (rpcMap[network]) {\n      return rpcMap[network];\n    }\n\n    // 2. Check for wildcard RPC\n    if (rpcMap[\"*\"]) {\n      return rpcMap[\"*\"];\n    }\n\n    // 3. Create default RPC for this network\n    return createRpcClient(network as `${string}:${string}`, defaultRpcUrl);\n  };\n\n  return {\n    getAddresses: () => {\n      return [signer.address];\n    },\n\n    signTransaction: async (transaction: string, feePayer: Address, _: string) => {\n      if (feePayer !== signer.address) {\n        throw new Error(`No signer for feePayer ${feePayer}. Available: ${signer.address}`);\n      }\n\n      // Decode transaction from base64\n      const tx = decodeTransactionFromPayload({ transaction });\n\n      // Sign the transaction\n      const signableMessage = {\n        content: tx.messageBytes,\n        signatures: tx.signatures,\n      };\n\n      const [facilitatorSignatureDictionary] = await signer.signMessages([\n        signableMessage as never,\n      ]);\n\n      // Merge signatures and encode\n      const fullySignedTx = {\n        ...tx,\n        signatures: {\n          ...tx.signatures,\n          ...facilitatorSignatureDictionary,\n        },\n      };\n\n      return getBase64EncodedWireTransaction(fullySignedTx);\n    },\n\n    simulateTransaction: async (transaction: string, network: string) => {\n      const rpc = getRpcForNetwork(network);\n      const result = await rpc\n        .simulateTransaction(transaction as never, {\n          sigVerify: true,\n          replaceRecentBlockhash: false,\n          commitment: \"confirmed\",\n          encoding: \"base64\",\n        })\n        .send();\n\n      if (result.value.err) {\n        throw new Error(`Simulation failed: ${JSON.stringify(result.value.err)}`);\n      }\n    },\n\n    sendTransaction: async (transaction: string, network: string) => {\n      const rpc = getRpcForNetwork(network);\n      return await rpc\n        .sendTransaction(transaction as never, {\n          encoding: \"base64\",\n        })\n        .send();\n    },\n\n    confirmTransaction: async (signature: string, network: string) => {\n      const rpc = getRpcForNetwork(network);\n      const rpcCapabilities = createRpcCapabilitiesFromRpc(rpc);\n      await rpcCapabilities.confirmTransaction(signature);\n    },\n  };\n}\n"],"mappings":"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","names":["import_token","import_token_2022","import_kit","tx","import_kit","fetchMint"]}