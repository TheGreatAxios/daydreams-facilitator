"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  COMPUTE_BUDGET_PROGRAM_ADDRESS: () => COMPUTE_BUDGET_PROGRAM_ADDRESS,
  DEFAULT_COMPUTE_UNIT_LIMIT: () => DEFAULT_COMPUTE_UNIT_LIMIT,
  DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS: () => DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS,
  DEVNET_RPC_URL: () => DEVNET_RPC_URL,
  DEVNET_WS_URL: () => DEVNET_WS_URL,
  ExactSvmScheme: () => ExactSvmScheme,
  MAINNET_RPC_URL: () => MAINNET_RPC_URL,
  MAINNET_WS_URL: () => MAINNET_WS_URL,
  MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS: () => MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS,
  SOLANA_DEVNET_CAIP2: () => SOLANA_DEVNET_CAIP2,
  SOLANA_MAINNET_CAIP2: () => SOLANA_MAINNET_CAIP2,
  SOLANA_TESTNET_CAIP2: () => SOLANA_TESTNET_CAIP2,
  SVM_ADDRESS_REGEX: () => SVM_ADDRESS_REGEX,
  TESTNET_RPC_URL: () => TESTNET_RPC_URL,
  TESTNET_WS_URL: () => TESTNET_WS_URL,
  TOKEN_2022_PROGRAM_ADDRESS: () => TOKEN_2022_PROGRAM_ADDRESS,
  TOKEN_PROGRAM_ADDRESS: () => TOKEN_PROGRAM_ADDRESS,
  USDC_DEVNET_ADDRESS: () => USDC_DEVNET_ADDRESS,
  USDC_MAINNET_ADDRESS: () => USDC_MAINNET_ADDRESS,
  USDC_TESTNET_ADDRESS: () => USDC_TESTNET_ADDRESS,
  V1_TO_V2_NETWORK_MAP: () => V1_TO_V2_NETWORK_MAP,
  convertToTokenAmount: () => convertToTokenAmount,
  createRpcClient: () => createRpcClient,
  decodeTransactionFromPayload: () => decodeTransactionFromPayload,
  getTokenPayerFromTransaction: () => getTokenPayerFromTransaction,
  getUsdcAddress: () => getUsdcAddress,
  normalizeNetwork: () => normalizeNetwork,
  toClientSvmSigner: () => toClientSvmSigner,
  toFacilitatorSvmSigner: () => toFacilitatorSvmSigner,
  validateSvmAddress: () => validateSvmAddress
});
module.exports = __toCommonJS(src_exports);

// src/exact/client/scheme.ts
var import_compute_budget = require("@solana-program/compute-budget");
var import_token2 = require("@solana-program/token");
var import_token_20222 = require("@solana-program/token-2022");
var import_kit2 = require("@solana/kit");

// src/constants.ts
var TOKEN_PROGRAM_ADDRESS = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
var TOKEN_2022_PROGRAM_ADDRESS = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
var COMPUTE_BUDGET_PROGRAM_ADDRESS = "ComputeBudget111111111111111111111111111111";
var DEVNET_RPC_URL = "https://api.devnet.solana.com";
var TESTNET_RPC_URL = "https://api.testnet.solana.com";
var MAINNET_RPC_URL = "https://api.mainnet-beta.solana.com";
var DEVNET_WS_URL = "wss://api.devnet.solana.com";
var TESTNET_WS_URL = "wss://api.testnet.solana.com";
var MAINNET_WS_URL = "wss://api.mainnet-beta.solana.com";
var USDC_MAINNET_ADDRESS = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
var USDC_DEVNET_ADDRESS = "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU";
var USDC_TESTNET_ADDRESS = "4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU";
var DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 1;
var MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS = 5e6;
var DEFAULT_COMPUTE_UNIT_LIMIT = 6500;
var SVM_ADDRESS_REGEX = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;
var SOLANA_MAINNET_CAIP2 = "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp";
var SOLANA_DEVNET_CAIP2 = "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1";
var SOLANA_TESTNET_CAIP2 = "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z";
var V1_TO_V2_NETWORK_MAP = {
  solana: SOLANA_MAINNET_CAIP2,
  "solana-devnet": SOLANA_DEVNET_CAIP2,
  "solana-testnet": SOLANA_TESTNET_CAIP2
};

// src/utils.ts
var import_kit = require("@solana/kit");
var import_token = require("@solana-program/token");
var import_token_2022 = require("@solana-program/token-2022");
function normalizeNetwork(network) {
  if (network.includes(":")) {
    const supported = [SOLANA_MAINNET_CAIP2, SOLANA_DEVNET_CAIP2, SOLANA_TESTNET_CAIP2];
    if (!supported.includes(network)) {
      throw new Error(`Unsupported SVM network: ${network}`);
    }
    return network;
  }
  const caip2Network = V1_TO_V2_NETWORK_MAP[network];
  if (!caip2Network) {
    throw new Error(`Unsupported SVM network: ${network}`);
  }
  return caip2Network;
}
function validateSvmAddress(address) {
  return SVM_ADDRESS_REGEX.test(address);
}
function decodeTransactionFromPayload(svmPayload) {
  try {
    const base64Encoder = (0, import_kit.getBase64Encoder)();
    const transactionBytes = base64Encoder.encode(svmPayload.transaction);
    const transactionDecoder = (0, import_kit.getTransactionDecoder)();
    return transactionDecoder.decode(transactionBytes);
  } catch (error) {
    console.error("Error decoding transaction:", error);
    throw new Error("invalid_exact_svm_payload_transaction");
  }
}
function getTokenPayerFromTransaction(transaction) {
  const compiled = (0, import_kit.getCompiledTransactionMessageDecoder)().decode(
    transaction.messageBytes
  );
  const staticAccounts = compiled.staticAccounts ?? [];
  const instructions = compiled.instructions ?? [];
  for (const ix of instructions) {
    const programIndex = ix.programAddressIndex;
    const programAddress = staticAccounts[programIndex].toString();
    if (programAddress === import_token.TOKEN_PROGRAM_ADDRESS.toString() || programAddress === import_token_2022.TOKEN_2022_PROGRAM_ADDRESS.toString()) {
      const accountIndices = ix.accountIndices ?? [];
      if (accountIndices.length >= 4) {
        const ownerIndex = accountIndices[3];
        const ownerAddress = staticAccounts[ownerIndex].toString();
        if (ownerAddress) return ownerAddress;
      }
    }
  }
  return "";
}
function createRpcClient(network, customRpcUrl) {
  const caip2Network = normalizeNetwork(network);
  switch (caip2Network) {
    case SOLANA_DEVNET_CAIP2: {
      const url = customRpcUrl || DEVNET_RPC_URL;
      return (0, import_kit.createSolanaRpc)((0, import_kit.devnet)(url));
    }
    case SOLANA_TESTNET_CAIP2: {
      const url = customRpcUrl || TESTNET_RPC_URL;
      return (0, import_kit.createSolanaRpc)((0, import_kit.testnet)(url));
    }
    case SOLANA_MAINNET_CAIP2: {
      const url = customRpcUrl || MAINNET_RPC_URL;
      return (0, import_kit.createSolanaRpc)((0, import_kit.mainnet)(url));
    }
    default:
      throw new Error(`Unsupported network: ${network}`);
  }
}
function getUsdcAddress(network) {
  const caip2Network = normalizeNetwork(network);
  switch (caip2Network) {
    case SOLANA_MAINNET_CAIP2:
      return USDC_MAINNET_ADDRESS;
    case SOLANA_DEVNET_CAIP2:
      return USDC_DEVNET_ADDRESS;
    case SOLANA_TESTNET_CAIP2:
      return USDC_TESTNET_ADDRESS;
    default:
      throw new Error(`No USDC address configured for network: ${network}`);
  }
}
function convertToTokenAmount(decimalAmount, decimals) {
  const amount = parseFloat(decimalAmount);
  if (isNaN(amount)) {
    throw new Error(`Invalid amount: ${decimalAmount}`);
  }
  const tokenAmount = Math.floor(amount * Math.pow(10, decimals));
  return tokenAmount.toString();
}

// src/exact/client/scheme.ts
var ExactSvmScheme = class {
  /**
   * Creates a new ExactSvmClient instance.
   *
   * @param signer - The SVM signer for client operations
   * @param config - Optional configuration with custom RPC URL
   * @returns ExactSvmClient instance
   */
  constructor(signer, config) {
    this.signer = signer;
    this.config = config;
    this.scheme = "exact";
  }
  /**
   * Creates a payment payload for the Exact scheme.
   *
   * @param x402Version - The x402 protocol version
   * @param paymentRequirements - The payment requirements
   * @returns Promise resolving to a payment payload
   */
  async createPaymentPayload(x402Version, paymentRequirements) {
    const rpc = createRpcClient(paymentRequirements.network, this.config?.rpcUrl);
    const tokenMint = await (0, import_token_20222.fetchMint)(rpc, paymentRequirements.asset);
    const tokenProgramAddress = tokenMint.programAddress;
    if (tokenProgramAddress.toString() !== import_token2.TOKEN_PROGRAM_ADDRESS.toString() && tokenProgramAddress.toString() !== import_token_20222.TOKEN_2022_PROGRAM_ADDRESS.toString()) {
      throw new Error("Asset was not created by a known token program");
    }
    const [sourceATA] = await (0, import_token_20222.findAssociatedTokenPda)({
      mint: paymentRequirements.asset,
      owner: this.signer.address,
      tokenProgram: tokenProgramAddress
    });
    const [destinationATA] = await (0, import_token_20222.findAssociatedTokenPda)({
      mint: paymentRequirements.asset,
      owner: paymentRequirements.payTo,
      tokenProgram: tokenProgramAddress
    });
    const transferIx = (0, import_token_20222.getTransferCheckedInstruction)(
      {
        source: sourceATA,
        mint: paymentRequirements.asset,
        destination: destinationATA,
        authority: this.signer,
        amount: BigInt(paymentRequirements.amount),
        decimals: tokenMint.data.decimals
      },
      { programAddress: tokenProgramAddress }
    );
    const feePayer = paymentRequirements.extra?.feePayer;
    if (!feePayer) {
      throw new Error("feePayer is required in paymentRequirements.extra for SVM transactions");
    }
    const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();
    const tx = (0, import_kit2.pipe)(
      (0, import_kit2.createTransactionMessage)({ version: 0 }),
      (tx2) => (0, import_compute_budget.setTransactionMessageComputeUnitPrice)(DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS, tx2),
      (tx2) => (0, import_kit2.setTransactionMessageFeePayer)(feePayer, tx2),
      (tx2) => (0, import_kit2.prependTransactionMessageInstruction)(
        (0, import_compute_budget.getSetComputeUnitLimitInstruction)({ units: DEFAULT_COMPUTE_UNIT_LIMIT }),
        tx2
      ),
      (tx2) => (0, import_kit2.appendTransactionMessageInstructions)([transferIx], tx2),
      (tx2) => (0, import_kit2.setTransactionMessageLifetimeUsingBlockhash)(latestBlockhash, tx2)
    );
    const signedTransaction = await (0, import_kit2.partiallySignTransactionMessageWithSigners)(tx);
    const base64EncodedWireTransaction = (0, import_kit2.getBase64EncodedWireTransaction)(signedTransaction);
    const payload = {
      transaction: base64EncodedWireTransaction
    };
    return {
      x402Version,
      payload
    };
  }
};

// src/signer.ts
var import_kit3 = require("@solana/kit");
function toClientSvmSigner(signer) {
  return signer;
}
function createRpcCapabilitiesFromRpc(rpc) {
  return {
    getBalance: async (address) => {
      const result = await rpc.getBalance(address).send();
      return result.value;
    },
    getTokenAccountBalance: async (address) => {
      const accountInfo = await rpc.getAccountInfo(address, {
        encoding: "jsonParsed"
      }).send();
      if (!accountInfo.value) {
        throw new Error(`Token account not found: ${address}`);
      }
      const parsed = accountInfo.value.data;
      return BigInt(parsed.parsed.info.tokenAmount.amount);
    },
    getLatestBlockhash: async () => {
      const result = await rpc.getLatestBlockhash().send();
      return {
        blockhash: result.value.blockhash,
        lastValidBlockHeight: result.value.lastValidBlockHeight
      };
    },
    simulateTransaction: async (transaction, config) => {
      return await rpc.simulateTransaction(transaction, config).send();
    },
    sendTransaction: async (transaction) => {
      return await rpc.sendTransaction(transaction, {
        encoding: "base64"
      }).send();
    },
    confirmTransaction: async (signature) => {
      let confirmed = false;
      let attempts = 0;
      const maxAttempts = 30;
      while (!confirmed && attempts < maxAttempts) {
        const status = await rpc.getSignatureStatuses([signature]).send();
        if (status.value[0]?.confirmationStatus === "confirmed" || status.value[0]?.confirmationStatus === "finalized") {
          confirmed = true;
          return status.value[0];
        }
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        attempts++;
      }
      throw new Error("Transaction confirmation timeout");
    },
    fetchMint: async (address) => {
      const { fetchMint: fetchMint2 } = await import("@solana-program/token-2022");
      return await fetchMint2(rpc, address);
    }
  };
}
function toFacilitatorSvmSigner(signer, rpcConfig) {
  let rpcMap = {};
  let defaultRpcUrl;
  if (rpcConfig) {
    if ("defaultRpcUrl" in rpcConfig && typeof rpcConfig.defaultRpcUrl === "string") {
      defaultRpcUrl = rpcConfig.defaultRpcUrl;
    } else if ("getBalance" in rpcConfig || "getSlot" in rpcConfig) {
      rpcMap["*"] = rpcConfig;
    } else {
      rpcMap = rpcConfig;
    }
  }
  const getRpcForNetwork = (network) => {
    if (rpcMap[network]) {
      return rpcMap[network];
    }
    if (rpcMap["*"]) {
      return rpcMap["*"];
    }
    return createRpcClient(network, defaultRpcUrl);
  };
  return {
    getAddresses: () => {
      return [signer.address];
    },
    signTransaction: async (transaction, feePayer, _) => {
      if (feePayer !== signer.address) {
        throw new Error(`No signer for feePayer ${feePayer}. Available: ${signer.address}`);
      }
      const tx = decodeTransactionFromPayload({ transaction });
      const signableMessage = {
        content: tx.messageBytes,
        signatures: tx.signatures
      };
      const [facilitatorSignatureDictionary] = await signer.signMessages([
        signableMessage
      ]);
      const fullySignedTx = {
        ...tx,
        signatures: {
          ...tx.signatures,
          ...facilitatorSignatureDictionary
        }
      };
      return (0, import_kit3.getBase64EncodedWireTransaction)(fullySignedTx);
    },
    simulateTransaction: async (transaction, network) => {
      const rpc = getRpcForNetwork(network);
      const result = await rpc.simulateTransaction(transaction, {
        sigVerify: true,
        replaceRecentBlockhash: false,
        commitment: "confirmed",
        encoding: "base64"
      }).send();
      if (result.value.err) {
        throw new Error(`Simulation failed: ${JSON.stringify(result.value.err)}`);
      }
    },
    sendTransaction: async (transaction, network) => {
      const rpc = getRpcForNetwork(network);
      return await rpc.sendTransaction(transaction, {
        encoding: "base64"
      }).send();
    },
    confirmTransaction: async (signature, network) => {
      const rpc = getRpcForNetwork(network);
      const rpcCapabilities = createRpcCapabilitiesFromRpc(rpc);
      await rpcCapabilities.confirmTransaction(signature);
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  COMPUTE_BUDGET_PROGRAM_ADDRESS,
  DEFAULT_COMPUTE_UNIT_LIMIT,
  DEFAULT_COMPUTE_UNIT_PRICE_MICROLAMPORTS,
  DEVNET_RPC_URL,
  DEVNET_WS_URL,
  ExactSvmScheme,
  MAINNET_RPC_URL,
  MAINNET_WS_URL,
  MAX_COMPUTE_UNIT_PRICE_MICROLAMPORTS,
  SOLANA_DEVNET_CAIP2,
  SOLANA_MAINNET_CAIP2,
  SOLANA_TESTNET_CAIP2,
  SVM_ADDRESS_REGEX,
  TESTNET_RPC_URL,
  TESTNET_WS_URL,
  TOKEN_2022_PROGRAM_ADDRESS,
  TOKEN_PROGRAM_ADDRESS,
  USDC_DEVNET_ADDRESS,
  USDC_MAINNET_ADDRESS,
  USDC_TESTNET_ADDRESS,
  V1_TO_V2_NETWORK_MAP,
  convertToTokenAmount,
  createRpcClient,
  decodeTransactionFromPayload,
  getTokenPayerFromTransaction,
  getUsdcAddress,
  normalizeNetwork,
  toClientSvmSigner,
  toFacilitatorSvmSigner,
  validateSvmAddress
});
//# sourceMappingURL=index.js.map